*libmodal.txt*          Plugin for managing tabs
*libmodal*
*vim-libmodal*

1. About                                   |libmodal-about|
2. Installation                            |libmodal-installation|
3. Usage                                   |libmodal-usage|
4. Configuration                           |libmodal-configuration|


============================================================================
1. About                                          *libmodal-about*

|vim-libmodal|:
- Author, Iron-E @ https://github.com/Iron-E & https://gitlab.com/Iron-E
- GitHub @ https://github.com/Iron-E/vim-libmodal

Forked from |vim-win|:
- Author, Daniel Steinberg @ https://www.dannyadam.com
- GitHub @ https://github.com/dstein64/vim-win

|libmodal| is a Neo/vim library/plugin aimed at simplifying the creation
of new "modes" (e.g. Insert, Normal). The entrance of modes is
user-defined, and their exit defaults to `<Esc>`. The function and name of
modes is also user-defined, and is outlined in |libmodal-usage|.

See: |vim-modes|

============================================================================
2. Installation                            *libmodal-installation*

Use |packages| or one of the various package managers.

Manager    Command
-------    -------
dein.vim   `call dein#add('https://github.com/Iron-E/vim-libmodal')`
NeoBundle  `NeoBundle 'https://github.com/Iron-E/vim-libmodal'`
Vim-Plug   `Plug 'https://github.com/Iron-E/vim-libmodal'`
Vundle     `Plugin 'https://github.com/Iron-E/vim-libmodal'`

============================================================================
3. Usage                                   *libmodal-usage*

Commands ~
                                                            *libmodal#Enter*

|libmodal#Enter| takes three parameters. These parameters are not formally named
by the editor (as |libmodal#Enter| is declared `libmodal#Enter(`|...|`)` ).
However, the names of these parameters will be used throughout the document to
describe the index of the parameter (see |E740|).

Arg            Index Use
---            ----- ---
`modeName`     0     The name for the mode when prompting the user.
`modeCallback` 1     The function used to control the mode.
`modeCombos`   1     A dictionary of |libmodal-key-combinations|.
`supressExit`  2     A flag to enable |libmodal-exit-supression|.

- Note that either `modeCallback` OR `modeCombos` may be specified, not both.

                                                           *libmodal#Prompt*

|libmodal#Prompt| takes two parameters. These parameters are not formally named
by the editor (as |libmodal#Prompt| is declared `libmodal#Prompt(`|...|`)` ).
However, the names of these parameters will be used throughout the document to
describe the index of the parameter (see |E740|).

Arg            Index Use
---            ----- ---
`modeName`     0     The name for the mode when prompting the user.
`modeCallback` 1     The function used to control the mode.
`modeCommands` 1     A dictionary of commands→strings to execute.
`commandList`  2     A list of the commands in a `modeCallback`.

- Note that either `modeCallback` OR `modeCommands` may be specified, not both.
- Note that `commandList` is an optional parameter.
  - It is used as a completion source for when `modeCallback` is specified.
  - Additionally, `commandList` is IGNORED when `modeCommands` is specified
	since completions can be created from the dictionary keys.
  - If `commandList` is not specified when `modeCallback` is, no completions
	will be provided for the prompt.


Receiving Input ~
                                                  *libmodal-receiving-input*

When a user of |libmodal| calls |libmodal#Enter|, the `modeName` parameter is
used to generate a unique global variable for the specific purpose of
receiving said input. The variable is generated as follows:

>
	let g:{tolower(a:modeName)}ModeInput = …
<

For example, if `modeName` is 'FOO', then the variable that is created is
`g:fooModeInput`.

Creating Modes ~
                                                   *libmodal-creating-modes*

For an example of a plugin that uses `vim-libmodal`, see
https://github.com/Iron-E/vim-tabmode.

To define a new mode, you must first create a function to pass into
|libmodal#Enter|. Example:

>
	function! s:FooMode()
		if g:fooModeInput ==# "a"
			execute 'tabnew'
		elseif g:fooModeInput ==# "d"
			execute 'tabclose'
		endif
	endfunction
<

After defining said function, you can create a mapping to enter the
mode. Be sure to use `<expr>`. Example:

>
	command! FooModeEnter call libmodal#Enter('FOO', funcref('s:FooMode'))
	nnoremap <expr> <leader>n FooModeEnter
<

- Note the `funcref()` call. It must be there or else `libmodal#Enter` won't
  execute properly.

                                                 *libmodal-key-combinations*

While normally |libmodal| dictates that a user should define their own
function for controlling a mode, there is a way to specify key combinations.
If the second argument is set to a `modeCombos` dictionary, |libmodal#Enter|
will automatically detect the caller's intent and pass control over to an
auxilliary function built to handle pre-defined combos.

When providing `modeCombos`, it is important to note that one no longer has to
receive input for themselves. Despite this, the unique variable (see
|libmodal-receiving-input|) is still updated, and you can create a listener
for it just like for any other variable.

- Note that |libmodal-exit-supression| is still compatable with defining
  key combinations.

Here is an example that shows how to create a dictionary that defines the
following actions:

Combo Action
----- ------
`zfo` Echo a message saying "It works!"
`zfc` Create a new tab.

>
	let s:barModeCombos = {
	\	'zfo': 'echom "It works!"',
	\	'zfc': 'tabnew'
	\}
<

And then to enter that mode, you can call:

>
	call libmodal#Enter('BAR', s:barModeCombos)
<

|libmodal|'s internal processing of that dictionary becomes more useful the
larger the dictionary is. Internally, `s:barModeCombos` is rendered into a
dictionary that looks like this:

>
	let s:barModeCombosInternal = {
	\	'z': {
	\		'f': {
	\			'c': 'echom "It works!"',
	\			'o': 'tabnew'
	\		}
	\	}
	\}
<

This allows |libmodal| to quickly determine which mappings are and are not
part of the mode. Because of this method, modes with mappings that have
similar beginnings are more efficient, and modes with more mappings get more
benefit from the quick tree-like traversal.

- Note that |libmodal#Enter| will only parse a `modeCombos` dict once upon
  entrance.
  - Changes to the mapping dictionary that may occur while in a mode
    are not reflected until the mode is entered again and the dictionary is
    re-parsed.

                                                  *libmodal-exit-supression*

When the `supressExit` parameter is specified, |libmodal#Enter| will ignore
`<Esc>` presses and instead listen for changes to a unique variable created
for the specific purpose of exiting the mode. The variable is generated as
follows:

>
	let g:{tolower(a:modeName)}ModeExit = 0
<

When this variable becomes set to `1`, the mode will exit the next time that
the `modeCallback` function returns.

Creating Prompts ~
                                                 *libmodal-creating-prompts*

Besides accepting user input like keys in |Normal-mode|, |libmodal| is also
capable of prompting the user for input like |Cmdline-mode|. To define a
|Cmdline-mode|-like prompt, use |libmodal#Prompt| rather than |libmodal#Enter|.

When `modeCommands` is specified, completions are provided for every key in
the dictionary. See an example of this below:

>
	let s:barModeCommands = {
	\	'new': 'tabnew',
	\	'close': 'tabclose',
	\	'last': 'tablast'
	\}
<

When `modeCallback` is specified, completions must be provided separately.
An equivalent to the above using a `modeCallback` would be:

>
	" Define callback
	function! s:BarMode() abort
		if g:barModeInput ==# 'new'
			execute 'tabnew'
		elseif g:barModeInput ==# 'close'
			execute 'tabclose'
		elseif g:barModeInput ==# 'last'
			execute 'tablast'
		endif
	endfunction

	" Define completion list
	let s:barModeCommandList = ['new', 'close', 'last']
<

You can then enter the mode using one of the following commands (depending on
whether or not you used a dictionary or a callback):

>
	" Command dict
	call libmodal#Prompt('BAR', s:barModeCommands)
	" Callback + completion list
	call libmodal#Prompt('BAR', funcref('s:BarMode'), s:barModeCommandList)
<

- Note that if you want to create commands with arguments, you will need to
  use a callback.

Submodes ~
                                                         *libmodal-submodes*

|libmodal| has built-in support for entering additional modes while already in
a |libmodal| mode. To enter another mode, one must only call |libmodal#Enter|
from within a `modeCallback`. Additionally, when a user presses `<Esc>` they
will automatically be taken back to the mode that they were previously inside
of.

To display this feature, one may alter the `echom 'It works!'` line from the
above example, and change it to the following:

>
	call libmodal#Enter('BAR2', funcref('s:BarMode'))
<

This will trigger |libmodal#Enter| to start a new mode called 'BAR2'. When the
user presses `<Esc>`, they will automatically be returned to 'BAR'.

============================================================================
4. Configuration                           *libmodal-configuration*

The following highlight groups can be configured to change a mode's colors:

Name              Default      Description
----              -------      -----------
`LibmodalPrompt`  `ModeMsg`    Color for the mode text.
`LibmodalStar`    `StatusLine` Color for the `*` at the beginning.

============================================================================
 vim:tw=78:ts=4:ft=help:norl:
