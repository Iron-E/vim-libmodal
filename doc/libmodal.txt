*libmodal.txt*          Plugin for managing tabs
*libmodal*

Forked From: vim-win – https://github.com/dstein64/vim-win
Original Author: Daniel Steinberg – https://www.dannyadam.com

Author: Iron-E – https://github.com/Iron-E & https://gitlab.com/Iron-E
Web: https://github.com/Iron-E/vim-libmodal

1. Requirements                            |libmodal-requirements|
2. Installation                            |libmodal-installation|
3. Usage                                   |libmodal-usage|
4. Configuration                           |libmodal-configuration|

|libmodal| is a Neo/vim library/plugin aimed at simplifying the creation
of new "modes" (e.g. Insert, Normal). The entrance of modes is
user-defined, and their exit defaults to `<Esc>`. The function and name of
modes is also user-defined, and is outlined in |libmodal-usage|.

See: |vim-modes|

============================================================================
1. Requirements                            *libmodal-requirements*

* `vim>=8.2` or `nvim>=0.4.0`

============================================================================
2. Installation                            *libmodal-installation*

Use |packages| or one of the various package managers.

Package Managers ~
                                                 *libmodal-package-managers*

Manager    Command
-------    -------
dein.vim   `call dein#add('https://github.com/Iron-E/vim-libmodal')`
NeoBundle  `NeoBundle 'https://github.com/Iron-E/vim-libmodal'`
Vim-Plug   `Plug 'https://github.com/Iron-E/vim-libmodal'`
Vundle     `Plugin 'https://github.com/Iron-E/vim-libmodal'`

============================================================================
3. Usage                                   *libmodal-usage*
                                                            *libmodal#Enter*

|libmodal#Enter| takes three parameters. These parameters are not formally named
by the editor (as |libmodal#Enter| is declared `libmodal#Enter(`|...|`)` ).
However, the names of these parameters will be used throughout the document to
describe the index of the parameter (see |E740|).

Arg            Index Use
---            ----- ---
`modeName`     0     The name for the mode when prompting the user.
`modeCallback` 1     The function used to control the mode.
`modeCombos`   1     A dictionary of key combos.
`supressExit`  2     Whether or not to leave the mode on (`<Esc>`).

Note that either `modeCallback` OR `modeCombos` may be specified, not both.

Receiving Input ~
                                                  *libmodal-receiving-input*

When a user of |libmodal| calls |libmodal#Enter|, the `modeName` parameter is
used to generate a unique global variable for the specific purpose of
receiving said input. The variable is generated as follows:

>
	let g:{tolower(a:modeName)}ModeInput = …
<

For example, if `modeName` is 'FOO', then the variable that is created is
`g:fooModeInput`.

Supressing Exit ~
                                                  *libmodal-supressing-exit*

When the `supressExit` parameter is specified, |libmodal#Enter| will ignore
`<Esc>` presses and instead listen for changes to a unique variable created
for the specific purpose of exiting the mode. The variable is generated as
follows:

>
	let g:{tolower(a:modeName)}ModeExit = 0
<

When this variable becomes set to `1`, the mode will exit the next time that
the `modeCallback` function returns.

Creating Modes ~
                                                   *libmodal-creating-modes*

For an example of a plugin that uses `vim-libmodal`, see
https://github.com/Iron-E/vim-tabmode.

To define a new mode, you must first create a function to pass into
|libmodal#Enter|. Example:

>
	function! s:FooMode()
		if g:fooModeInput ==# "a"
			execute 'tabnew'
		elseif g:fooModeInput ==# "d"
			execute 'tabclose'
		endif
	endfunction
<

After defining said function, you can create a mapping to enter the
mode. Be sure to use `<expr>`. Example:

>
	command! FooModeEnter call libmodal#Enter('FOO', funcref('s:FooMode'))
	nnoremap <expr> <leader>n FooModeEnter
<

Note the `funcref()` call. It must be there or else `libmodal#Enter` won't
execute properly.

Key Combinations ~
                                                 *libmodal-key-combinations*

While normally |libmodal| dictates that a user should define their own
function for controlling a mode, there is a way to specify key combinations.
If the second argument is set to a `modeCombos` dictionary, |libmodal#Enter|
will automatically detect the caller's intent and pass control over to an
auxilliary function built to handle pre-defined combos.

When providing `modeCombos`, it is important to note that one no longer has to
receive input for themselves. Despite this, the unique variable (see
|libmodal-receiving-input|) is still updated, and you can create a listener
for it just like for any other variable.

Note that one may still supress exit (see |libmodal-supressing-exit|) while
defining key combinations.

Here is an example that shows how to create a dictionary that defines the
following actions:

Combo Action
----- ------
`zfo` Echo a message saying "It works!"
`zfc` Create a new tab.

>
	let s:barModeCombos = {
	\	'zfo': 'echom "It works!"',
	\	'zfc': 'tabnew'
	\}
<

And then to enter that mode, you can call:

>
	call libmodal#Enter('BAR', s:barModeCombos)
<

|libmodal|'s internal processing of that dictionary becomes more useful the
larger the dictionary is. Internally, `s:barModeCombos` is rendered into a
dictionary that looks like this:

>
	let s:barModeCombosInternal = {
	\	'z': {
	\		'f': {
	\			'c': 'echom "It works!"',
	\			'o': 'tabnew'
	\		}
	\	}
	\}
<

This allows |libmodal| to quickly determine which mappings are and are not
part of the mode. Because of this method, modes with mappings that have
similar beginnings are more efficient, and modes with more mappings get more
benefit from the quick tree-like traversal.

Note that |libmodal#Enter| will only parse a `modeCombos` dict once upon
entrance, so changes to the mapping dictionary that may occur while in a mode
are not reflected until the mode is entered again and the dictionary is
re-parsed.

Submodes ~
                                                         *libmodal-submodes*

|libmodal| has built-in support for entering additional modes while already in
a |libmodal| mode. To enter another mode, one must only call |libmodal#Enter|
from within a `modeCallback`. Additionally, when a user presses `<Esc>` they
will automatically be taken back to the mode that they were previously inside
of.

To display this feature, one may alter the `echom 'It works!'` line from the
above example, and change it to the following:

>
	call libmodal#Enter('BAR2', funcref('s:BarMode'))
<

This will trigger |libmodal#Enter| to start a new mode called 'BAR2'. When the
user presses `<Esc>`, they will automatically be returned to 'BAR'.

============================================================================
4. Configuration                           *libmodal-configuration*

The following highlight groups can be configured to change a mode's colors:

Name              Default      Description
----              -------      -----------
`LibmodalPrompt`  `ModeMsg`    Color for the mode text.
`LibmodalStar`    `StatusLine` Color for the `*` at the beginning.

============================================================================
 vim:tw=78:ts=4:ft=help:norl:
