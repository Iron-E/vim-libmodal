*libmodal.txt*          Plugin for managing tabs
*libmodal*

Forked From: vim-win – https://github.com/dstein64/vim-win
Original Author: Daniel Steinberg – https://www.dannyadam.com

Author: Iron-E – https://github.com/Iron-E & https://gitlab.com/Iron_E
Web: https://github.com/Iron-E/vim-libmodal

1. Requirements                            |libmodal-requirements|
2. Installation                            |libmodal-installation|
3. Usage                                   |libmodal-usage|
4. Configuration                           |libmodal-configuration|

|libmodal| is a Neo/vim library/plugin aimed at simplifying the creation
of new "modes" (e.g. Insert, Normal). The entrance of modes is
user-defined, and their exit is set to `<Esc>`. The function and name of
modes is also user-defined, and is outlined in |libmodal-usage|.

============================================================================
1. Requirements                            *libmodal-requirements*

* `vim>=8.2` or `nvim>=0.4.0`

============================================================================
2. Installation                            *libmodal-installation*

Use |packages| or one of the various package managers.

Package Managers ~
                                                 *libmodal-package-managers*

Manager    Command
-------    -------
dein.vim   `call dein#add('https://github.com/Iron_E/vim-libmodal')`
NeoBundle  `NeoBundle 'https://github.com/Iron_E/vim-libmodal'`
Vim-Plug   `Plug 'https://github.com/Iron_E/vim-libmodal'`
Vundle     `Plugin 'https://github.com/Iron_E/vim-libmodal'`

============================================================================
3. Usage                                   *libmodal-usage*
                                                            *libmodal#Enter*

|libmodal#Enter| takes two arguments: `modeName` and `modeCallback`.

Arg            Use
---            ---
`modeName`     The name for the mode when prompting the user.
`modeCallback` The function used to control the mode. Takes one char param.

Receiving Input ~
                                                  *libmodal-receiving-input*

When a user of |libmodal| calls |libmodal#Enter|, the `modeName` parameter is
used to generate a unique global variable for the specific purpose of
receiving said input. The variable is generated as follows:

>
	let g:{tolower(a:modeName)}ModeInput = …
<

For example, if `modeName` is 'FOO', then the variable that is created is
`g:fooModeInput`.

Creating Modes ~
                                                   *libmodal-creating-modes*

For an example of a plugin that uses `vim-libmodal`, see
https://github.com/Iron-E/vim-tabmode.

To define a new mode, you must first create a function to pass into
|libmodal#Enter|. Example:

>
	function! s:FooMode()
		if g:fooModeInput ==# "a"
			execute 'tabnew'
		elseif g:fooModeInput ==# "d"
			execute 'tabclose'
		endif
	endfunction
<

After defining said function, you can create a mapping to enter the
mode. Be sure to use `<expr>`. Example:

>
	command! FooModeEnter call libmodal#Enter('FOO', funcref('s:FooMode'))
	nnoremap <expr> <leader>n FooModeEnter
<

Note the `funcref()` call. It must be there or else `libmodal#Enter` won't
execute properly.

Key Combinations ~
                                                 *libmodal-key-combinations*

Although |libmodal| will overwrite your mode's unique variable with each key
press from a user (see |libmodal-usage--receiving-input|), a `modeCallback`
function can track previous keypresses in order to determine what action
should be taken. Here is an example that shows how to perform an action if the
user presses `zfo`:

>
	" Define history variable
	let s:barModeInputHistory = ''

	" Create function to conditionally clear history.
	function! s:ClearHistory(indexToCheck)
		" Only clear if there was actually enough input
		"     to reach the index specified.
		if len(s:barModeInputHistory)-1 >= a:indexToCheck
			let s:barModeInputHistory = ''
		endif
	endfunction

	" Define mode function
	function! s:BarMode()
		" Concatenate history string with input
		let s:barModeInputHistory .= g:barModeInput

		" Perform actions based on the history.
		if s:barModeInputHistory[0] ==# 'z'
			" Check if there are characters at index '1'.
			if s:barModeInputHistory[1] ==# 'f'
				" Check if there are characters at index '2'.
				if s:barModeInputHistory[2] ==# 'o'
					echom 'It works!'
					let l:index = 0
				" Clear the history if a character was provided at index
				"     '2' and it does not match any previous cases.
				else
					let l:index = 2
				endif

			" Clear the history if a character was provided at index '1'
			"     and it does not match any previous cases.
			else
				let l:index = 1
			endif
		else
			let l:index = 0
		endif

		call s:ClearHistory(l:index)
	endfunction
<

And then to enter that mode, you can call:

>
	call libmodal#Enter('BAR', funcref('s:BarMode'))
<

Note that any approach will work for tracking the history of input— this is
just an example. Because |libmodal| accepts a function as a parameter, its
limitations are few.

Submodes ~
                                                         *libmodal-submodes*

|libmodal| has built-in support for entering additional modes while already in
a |libmodal| mode. To enter another mode, one must only call |libmodal#Enter|
from within a `modeCallback`. Additionally, when a user presses `<Esc>` they
will automatically be taken back to the mode that they were previously inside
of.

To display this feature, one may alter the `echom 'It works!'` line from the
above example, and change it to the following:

>
	call libmodal#Enter('BAR2', funcref('s:BarMode'))
<

This will trigger |libmodal#Enter| to start a new mode called 'BAR2'. When the
user presses `<Esc>`, they will automatically be returned to 'BAR'.

============================================================================
4. Configuration                           *libmodal-configuration*

The following highlight groups can be configured to change a mode's colors:

Name              Default      Description
----              -------      -----------
`LibmodalPrompt`  `ModeMsg`    Color for the mode text.
`LibmodalStar`    `StatusLine` Color for the `*` at the beginning.

============================================================================
 vim:tw=78:ts=4:ft=help:norl:
